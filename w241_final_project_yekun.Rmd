---
title: "w241_final_project"
output:
  pdf_document: default
  html_document: default
  word_document: default
---

```{r,message=FALSE,error=FALSE}
library(stringr)
library(dplyr)
library(stargazer)
library(lmtest)
library(sandwich)
library(ggplot2)
library(magrittr)
library(lmtest)
library(ri2)
library(data.table)
library(tidyr)
```

## Loading Data

```{r,message=FALSE,error=FALSE}
d = read.csv('~/Desktop/PrelimRESULTS.csv')
#g1 = read.csv('~/Desktop/group1.csv')
#g2_sms = read.csv('~/Desktop/group2_SMS.csv')
#g2_no_sms = read.csv('~/Desktop/group2_NoSMS.csv')
s_prior = read.csv('~/Desktop/scripts_prior.csv')
s_during = read.csv('~/Desktop/scripts_during.csv')
```

## Examine data

```{r, include=FALSE}
# # How many users in the final data set? 
# which(duplicated(d$UniqueID))
# # there are duplicated records in the final data set
# 
# d[d$UniqueID %in% d$UniqueID[duplicated(d$UniqueID)],]
# # maybe we should merge the duplicated rows? by summing the drug count? 
# 
# # Join to assignment file
# df = d[,c('UniqueID','ACTIVE_IN._EXPERIMENT','TREATMENT','EXCLUDE')] %>%
#   filter(is.na(d$EXCLUDE))
# group1 = data.frame(UniqueID = g1$UniqueID, group = 'group_1', treatment = g1$Tr)
# group2_sms = data.frame(UniqueID = g2_sms$UniqueID, group = 'group_2_sms', treatment = g2_sms$Tr)
# group2_no_sms = data.frame(UniqueID = g2_no_sms$UniqueID, group = 'group_2_no_sms', treatment = g2_no_sms$Tr)
# 
# assignment = rbind(group1, group2_no_sms, group2_sms)
# df_1 = full_join(df, assignment)
# 
# nrow(filter(d, d$TREATMENT != '')) #185
# nrow(assignment) #156
# # There are more users in the final doc than the assignment groups... 
```

## Combining the PrelimRESULTS table with the two scripts table using left join.

```{r}
# find all carer patient relationship
carer_patient = rbind(s_prior,s_during) %>%
  mutate(Patient.self = UNIQUE.ID) %>%
  gather(., Patient, Patient_id, Patient.1:Patient.self, factor_key=TRUE) %>%
  filter(!is.na(Patient_id)) %>% data.table()

# create a list of distinct patient id
patient_id = unique(carer_patient[Patient != 'Patient.self',Patient_id])
# create a list of distinct carer id
carer_id = unique(carer_patient$UNIQUE.ID)

# clean scripts_prior file
s_p = s_prior %>% 
  transmute(
    id = UNIQUE.ID,
    date = DATE,
    total_meds = Medications.ordered,
    self_meds = Ordered.for.self,
    other_meds = ORDERED.FOR.OTHER) %>%
  filter(as.Date(s_prior$DATE,'%d/%m/%Y') >= as.Date('5/8/2019','%d/%m/%Y')) %>% # filter for prior three month only
  group_by(id) %>%
  summarise(
    total_meds_3m = sum(total_meds),
    self_meds_3m = sum(self_meds),
    other_meds_3m = sum(other_meds)
  )

# clean scripts_during file
s_d = s_during %>% 
  transmute(
    id = UNIQUE.ID,
    date = DATE,
    total_meds = Medications.ordered,
    self_meds = Ordered.for.self,
    other_meds = ORDERED.FOR.OTHER) %>%
  group_by(id) %>%
  summarise(
    total_meds_in_exp = sum(total_meds),
    self_meds_in_exp = sum(self_meds),
    other_meds_in_exp = sum(other_meds)
  )

# clean the final data file
df = d %>%
  transmute(id = UniqueID,
            treatment = ifelse(TREATMENT == '', '', ifelse(str_detect(TREATMENT,'CONTROL'), 0, 1)),
            phone = ifelse(TREATMENT == '', '', ifelse(str_detect(TREATMENT,'GROUP 1'), 0, 1)),
            sms = ifelse(TREATMENT == '', '', ifelse(str_detect(TREATMENT,'GROUP 1'), 0, ifelse(str_detect(TREATMENT,'NO SMS'),0,1))),
            active_in_exp = ifelse(is.na(ACTIVE_IN._EXPERIMENT), 0, 1),
            active_3m = ifelse(is.na(X3MONTH_ACTIVE.NEW.), 0, 1), # Use the new column!  
            voucher = ifelse(VOUCHER == '', 0, 1), 
            drug_count = ifelse(is.na(Drug.Count), 0, 1),
            nov05_fail = ifelse(is.na(Nov05_FAIL), 0, 1),
            nov13_fail = ifelse(is.na(Nov13_FAIL), 0, 1),
            nov23_fail = ifelse(is.na(Nov23_FAIL), 0, 1),
            unsub = ifelse(Unsubscribe_Request == '', 0, 1), 
            msg_fail = ifelse(is.na(Other_msg_fail), 0, 1),
            nursing_home = ifelse(is.na(Nursing_HOME), 0, 1),
            male = ifelse(is.na(MALE), 0, 1),
            reminder_type = Reminder.Type,
            address_group = Address.GROUP,
            address_group_i = ifelse(Address.GROUP == 0, 0, 1), # create an indicator variable used for covariate balance check
            carer_group = ifelse(is.na(CARER.GROUP), 0, CARER.GROUP),
            carer_group_i = ifelse(is.na(CARER.GROUP), 0, 1), # create an indicator variable used for covariate balance check
            carer_status = ifelse(UniqueID %in% patient_id, 0, 1), # find non-carers
            cell_phone = HAS_CELL_PHONE,
            email = HAS_EMAIL,
            cell_dup = ifelse(is.na(CELL_DUP_GP), 0, 1),
            name_dup = ifelse(is.na(NAME_DUP_GP), 0, 1)
            ) %>%
  filter(treatment != '') %>%
  filter(!duplicated(id)) %>% # removing duplicated row, because some users converted reminder type half way through the experiment
  filter(carer_status == 1) # removing all non-carer rows

df = df %>% 
  left_join(.,s_p) %>%
  left_join(.,s_d) %>% data.table()

# Note that at this point, each row represents a carer group, with the carer's id as the unique id
```

## Covariate Balance

```{r}
group_assignment = df %>% 
  select(id, treatment, phone, sms) %>%
  group_by(treatment, phone, sms) %>%
  summarise(count = n())
group_assignment
```

Note that I used carer_group_i and address_group_i to check covariate balance. I couldn't use the original variables, because the id's were interpretated as numeric. So I had to create these two binary dummy variable.

```{r}
library(RItools)
df$treatment = as.integer(df$treatment)
df$sms = as.integer(df$treatment)

# check covariant balance in the no phone group, with respect to treatment
xBalance(treatment ~ male + drug_count + active_3m + carer_group_i + address_group_i, 
         data = df[phone == 0,],
         report = 'all')

# check covariant balance in the has phone group, with respect to treatment
xBalance(treatment ~ male + drug_count + active_3m + carer_group_i + address_group_i, 
         data = df[phone == 1,],
         report = 'all')

# check covariant balance in the has phone group, with respect to sms
xBalance(sms ~ male + drug_count + active_3m + carer_group_i + address_group_i, 
         data = df[phone == 1,],
         report = 'all')
```

## Hypothesis 0: treatment effect, y = active login, x = treatment

### Random Inference: active login in exp ~ treatment, without correcting for clustered standard error
```{r, error= FALSE, message= FALSE}
# Define potential outcomes for control and treatment, under the sharp null hypothesis, these two vectors should be exactly the same

# Assign treatment and control potential outcomes
po.control = as.integer(df$active_in_exp)
po.treatment = po.control

# Randomly assign units into control and treatment group
randomize = function() {sample(c(rep(0,sum(df$treatment == 0)),rep(1,sum(df$treatment == 1))))}
t = randomize()

# Calculate the outcome according to control/treatment assignment
outcomes = po.treatment * t + po.control*(1-t)

# Estimate the Average Treatment Effect
est.ate = function(outcome,success){mean(outcome[success==1]) - mean(outcome[success==0])}
#est.ate(outcomes, randomize())

# Run simulation for 10,000 times
distribution.under.sharp.null <- replicate(10000, est.ate(outcomes, randomize()))

ATE = mean(as.numeric(df[df$treatment == 1]$active_in_exp)) - mean(as.numeric(df[df$treatment == 0]$active_in_exp))
p_value_two_tailed <- sum(abs(distribution.under.sharp.null) > ATE)/length(distribution.under.sharp.null)

qplot(distribution.under.sharp.null) +
 geom_vline(aes(xintercept = ATE,color = 'ATE')) + 
  ggtitle(paste('Model: active in experiment ~ treatment, ATE = ', round(ATE,4), ', p-value = ', p_value_two_tailed))
```

```{r}
lm0 = df[,lm(active_in_exp ~ treatment)] # base model
lm0$vcovCL1 = vcovCL(lm0, cluster = df[, c("address_group")])
#coeftest(lm0, vcov. = lm0$vcovCL1)

lm1 = df[,lm(active_in_exp ~ treatment + sms + treatment * sms)] # add sms
lm1$vcovCL1 = vcovCL(lm1, cluster = df[, c("address_group")])
#coeftest(lm1, vcov. = lm1$vcovCL1)

lm2 = df[,lm(active_in_exp ~ treatment + sms + phone + treatment * sms)] # add phone
lm2$vcovCL1 = vcovCL(lm2, cluster = df[, c("address_group")])
#coeftest(lm2, vcov. = lm2$vcovCL1)

lm4 = df[,lm(active_in_exp ~ treatment + sms + phone + male)] # add gender
lm4$vcovCL1 = vcovCL(lm4, cluster = df[, c("address_group")])
#coeftest(lm4, vcov. = lm4$vcovCL1)

lm3 = df[,lm(active_in_exp ~ treatment + sms + phone + active_3m + male + treatment * sms + treatment * active_3m )] # add active 3m
lm3$vcovCL1 = vcovCL(lm3, cluster = df[, c("address_group")])
#coeftest(lm3, vcov. = lm3$vcovCL1)

stargazer(lm0, lm1, lm2, lm4, lm3, 
          se = list(sqrt(diag(lm0$vcovCL1)),
                    sqrt(diag(lm1$vcovCL1)),
                    sqrt(diag(lm2$vcovCL1)),
                    sqrt(diag(lm4$vcovCL1)),
                    sqrt(diag(lm3$vcovCL1))), 
          type = 'text', header = FALSE, 
          omit.stat = c('F', 'ser')
)
```

- ATE is the same between RI and t-test, however, t-test uses clustered standard error. 
- Treatment effect is not significant.
- Having a phone number on file is more important
- Whether the user is active during the test period is highly correlated with whether he/she was active in the app three months before the experiment.
- None of the interaction terms is significant, so no significant differential treatment effect.

## Hypothesis 1: differential treatment effect by group, y = active login, x = treatment

```{r}
lm1 = df[phone == 0, lm(active_in_exp ~ treatment)] # base model
lm1$vcovCL1 = vcovCL(lm1, cluster = df[phone == 0, c("address_group")])
#coeftest(lm1, vcov. = lm1$vcovCL1)

lm2 = df[phone == 0,lm(active_in_exp ~ treatment + active_3m)] # add active history
lm2$vcovCL1 = vcovCL(lm2, cluster = df[phone == 0, c("address_group")])
#coeftest(lm2, vcov. = lm2$vcovCL1)

lm3 = df[phone == 1, lm(active_in_exp ~ treatment)] # base model
lm3$vcovCL1 = vcovCL(lm3, cluster = df[phone == 1, c("address_group")])
#coeftest(lm3, vcov. = lm3$vcovCL1)

lm4 = df[phone == 1, lm(active_in_exp ~ treatment + active_3m)] # add active history
lm4$vcovCL1 = vcovCL(lm4, cluster = df[phone == 1, c("address_group")])
#coeftest(lm4, vcov. = lm4$vcovCL1)

lm5 = df[phone == 1, lm(active_in_exp ~ treatment + active_3m + sms + treatment * active_3m + treatment * sms)] # add sms
lm5$vcovCL1 = vcovCL(lm5, cluster = df[phone == 1, c("address_group")])
#coeftest(lm5, vcov. = lm5$vcovCL1)

stargazer(lm1, lm2, lm3, lm4, lm5,
         se=list(sqrt(diag(lm1$vcovCL1)),
                 sqrt(diag(lm2$vcovCL1)),
                 sqrt(diag(lm3$vcovCL1)),
                 sqrt(diag(lm4$vcovCL1)),
                 sqrt(diag(lm5$vcovCL1))),
         type = 'text',header=FALSE,
         omit.stat = c('F', 'ser'),
         column.labels = c('No Phone', 'No Phone', 'Has Phone', 'Has Phone', 'Has Phone'))
```
- Treatment effect is significant in the 'No Phone' on record group!
- Otherwise, only the past active login history is significant in the 'Has Phone' group.

## Hypothesis 2: reminder effect on voucher uptake, y = voucher, x = sms

### Random Inference: voucher ~ sms, without correcting for clustered standard error
```{r, error= FALSE, message= FALSE}
# Define potential outcomes for control and treatment, under the sharp null hypothesis, these two vectors should be exactly the same
# Assign treatment and control potential outcomes
po.control = as.integer(df$voucher)
po.treatment = po.control

# Randomly assign units into control and treatment group
randomize = function() {sample(c(rep(0,sum(df$sms == 0)),rep(1,sum(df$sms == 1))))}
t = randomize()

# Calculate the outcome according to control/treatment assignment
outcomes = po.treatment * t + po.control*(1-t)

# Estimate the Average Treatment Effect
est.ate = function(outcome,success){mean(outcome[success==1]) - mean(outcome[success==0])}
#est.ate(outcomes, randomize())

# Run simulation for 10,000 times
distribution.under.sharp.null <- replicate(10000, est.ate(outcomes, randomize()))

ATE = mean(as.numeric(df[df$sms == 1]$voucher)) - mean(as.numeric(df[df$sms == 0]$voucher))
p_value_two_tailed <- sum(abs(distribution.under.sharp.null) > ATE)/length(distribution.under.sharp.null)

qplot(distribution.under.sharp.null) +
 geom_vline(aes(xintercept = ATE,color = 'ATE')) + 
 ggtitle(paste('Model: voucher ~ reminder, ATE = ', round(ATE,4), ', p-value = ', p_value_two_tailed)) + 
 ylab('')
```

```{r}
table(df$sms, df$voucher)

lm2 = df[phone == 1, lm(voucher ~ sms)] # sms
lm2$vcovCL1 = vcovCL(lm2, cluster = df[phone == 1, c("address_group")])
#coeftest(lm2, vcov. = lm2$vcovCL1)

lm1 = df[phone == 1, lm(voucher ~ sms + drug_count)] # add drug count
lm1$vcovCL1 = vcovCL(lm1, cluster = df[phone == 1, c("address_group")])
#coeftest(lm1, vcov. = lm1$vcovCL1)

lm3 = df[phone == 1, lm(voucher ~ sms + drug_count + male)] # add male
lm3$vcovCL1 = vcovCL(lm3, cluster = df[phone == 1, c("address_group")])
#coeftest(lm3, vcov. = lm3$vcovCL1)

lm4 = df[phone == 1, lm(voucher ~ sms + drug_count + male + active_3m)] # add active_3m
lm4$vcovCL1 = vcovCL(lm4, cluster = df[phone == 1, c("address_group")])
#coeftest(lm4, vcov. = lm4$vcovCL1)

stargazer(lm2, lm1, lm3, lm4,
          type = 'text', header = FALSE,
          se=list(sqrt(diag(lm2$vcovCL1)),
                 sqrt(diag(lm1$vcovCL1)),
                 sqrt(diag(lm3$vcovCL1)),
                 sqrt(diag(lm4$vcovCL1))),
          omit.stat = c('F', 'ser')
          )
```

- impact of sms is not significant
- but the impact of drug count and male is significant

## Hypothesis 3: treatment effect on scripts ordered, y = scripts ordered, x = treatment

```{r}
df$total_meds_in_exp = as.integer(ifelse(is.na(df$total_meds_in_exp),0,df$total_meds_in_exp)) # need to fill the NAs

# histogram
ggplot(data=df, aes(x = total_meds_in_exp, fill = as.factor(treatment))) + 
  geom_histogram(position="dodge")

# density plot
ggplot(df) + geom_freqpoly(aes(x = total_meds_in_exp,
     y = ..density.., colour = as.factor(treatment)))
```

- Highly skeweed distribution, normality assumption probably won't hold given the sample size

### Random Inference: total meds ordered in exp ~ treatment, without correcting for clustered standard error
```{r, error= FALSE, message= FALSE}
# Define potential outcomes for control and treatment, under the sharp null hypothesis, these two vectors should be exactly the same
df = na.fill(df,0) %>% data.table()

# Assign treatment and control potential outcomes
po.control = as.integer(df$total_meds_in_exp)
po.treatment = po.control

# Randomly assign units into control and treatment group
randomize = function() {sample(c(rep(0,sum(df$treatment == 0)),rep(1,sum(df$treatment == 1))))}
t = randomize()

# Calculate the outcome according to control/treatment assignment
outcomes = po.treatment * t + po.control*(1-t)

# Estimate the Average Treatment Effect
est.ate = function(outcome,success){mean(outcome[success==1]) - mean(outcome[success==0])}
#est.ate(outcomes, randomize())

# Run simulation for 10,000 times
distribution.under.sharp.null <- replicate(10000, est.ate(outcomes, randomize()))

ATE = mean(as.numeric(df[df$treatment == 1]$total_meds_in_exp)) - mean(as.numeric(df[df$treatment == 0]$total_meds_in_exp))
p_value_two_tailed <- sum(abs(distribution.under.sharp.null) > ATE)/length(distribution.under.sharp.null)

qplot(distribution.under.sharp.null) +
 geom_vline(aes(xintercept = ATE,color = 'ATE')) + 
  ggtitle(paste('Model: total meds in experiment ~ treatment, ','ATE = ', round(ATE,4), ', p-value = ', p_value_two_tailed))
```

- ATE is the same between RI and t-test, however, t-test uses clustered standard error. 

```{r}
table(df$treatment, df$total_meds_in_exp)

df$total_meds_in_exp = as.integer(df$total_meds_in_exp)
df$total_meds_3m = as.integer(df$total_meds_3m)

## No Phone Group
lm0 = df[phone == 0, lm(total_meds_in_exp ~ treatment)] # no phone
lm0$vcovCL1 = vcovCL(lm0, cluster = df[phone == 0, c("address_group")])
#coeftest(lm0, vcov. = lm0$vcovCL1)

lm1 = df[phone == 0, lm(total_meds_in_exp ~ treatment + total_meds_3m + treatment * total_meds_3m)] # add scripts 3m
lm1$vcovCL1 = vcovCL(lm1, cluster = df[phone == 0, c("address_group")])
#coeftest(lm1, vcov. = lm1$vcovCL1)

## Has Phone Group
lm6 = df[phone == 1, lm(total_meds_in_exp ~ treatment)] # has phone
lm6$vcovCL1 = vcovCL(lm6, cluster = df[phone == 1, c("address_group")])
#coeftest(lm6, vcov. = lm6$vcovCL1)

lm2 = df[phone == 1, lm(total_meds_in_exp ~ treatment + sms + treatment * sms)] # add sms
lm2$vcovCL1 = vcovCL(lm2, cluster = df[phone == 1, c("address_group")])
#coeftest(lm2, vcov. = lm2$vcovCL1)

lm4 = df[phone == 1, lm(total_meds_in_exp ~ treatment + sms + total_meds_3m + treatment * sms + treatment * total_meds_3m)] # add total meds 3m
lm4$vcovCL1 = vcovCL(lm4, cluster = df[phone == 1, c("address_group")])
#coeftest(lm4, vcov. = lm4$vcovCL1)

stargazer(lm0, lm1, lm6, lm2, lm4,
          se = list(sqrt(diag(lm0$vcovCL1)),
                    sqrt(diag(lm1$vcovCL1)),
                    sqrt(diag(lm6$vcovCL1)),
                    sqrt(diag(lm2$vcovCL1)),
                    sqrt(diag(lm4$vcovCL1))), 
          type = 'text', header = FALSE, 
          omit.stat = c('F', 'ser'),
          column.labels = c('No Phone', 'No Phone', 'Has Phone', 'Has Phone', 'Has Phone')
          )
```

- model (1): for the 'No Phone' group, being in the treatment group is predictive of total meds ordered during the experiment
- model (2): power user effect - total meds ordered in the past 3 months is highly predictive of total meds ordered during the experiment
- dont know how to interpret model (3) and (4)... maybe we should take them out
- model (5) receiving a sms reminder has a negative impact on total meds ordered?


